<?php
// Lesson 2

// 1. Какие типы паттернов проектирования существуют?
// Порождающеие, поведенческие и структурные.

// 2. Как можно улучшить Singleton при помощи trait-ов?
// Можно реализовать Singleton с помощью трейта, а затем внедрять его в класс в виде этого трейта. Получить единственный
// экземпляр класса можно прямо из класса вызвав метод ClassName::getInstance.

// 3. Как реализуется паттерн Фабричный метод? В чем его отличие от паттерна Фабрика?
// При использовании фабричного метода новый объект создается не напрямую через new, а с помощью другого класса, который
// в свою очередь может делегировать создание объекта своим подклассам. Фабричный метод может возвращать разные объекты
// в зависимости от контекста, при этом они подчиняются общему интерфейсу.
// Абстрактная фабрика позволяет создавать семейство объектов связанных между собой. Она не привязана к конкретным
// классам и неичего не знает о создаваемом объекте, она лишь задает семейство объектов, а при создании конкретного
// объекта уже может использоваться фабричный метод.

// 4. Объясните назначение и применение магических методов __get, __set, __isset, __unset, __call и __callStatic. Когда,
// как и почему их стоит использовать (или нет)?
// Метод __get вызывается когда происходит обращение к несуществующему или закрытому свойству класса. Соответственно
// метод __set вызывается когда происходит попытка записать несущечтвующее или закрытое свойство. Таким образом можно
// инкапсулировать доступ к свойствам, или как-то по другому обработать запрос, вернуть другое свойство. Метод __isset
// вызывается когда была вызвана функция isset() для проверки существования свойства объекта. Таким образом можно
// сообщить о существовании закрытого свойства или как-то по другому обработать действие. Аналогично можно использовать
// метод __unset, при попытке очистить свойство. Магический метод __call работает аналогично методу __get, но при
// вызове закрытого или не существующего метода. Можно переопределить метод или делегировать другому методу.
// __callStatic вызывается при обращении к статическому методу класса.

// 5. Опишите несколько структур данных из стандартной библиотеки PHP (SPL). Приведите примеры использования.
// SplObjectStorage представляет собой хранилище объектов, и предоставляет удобные инструменты для работы с объектами.
// Объекты можно легко добавлять и удалять, перебирать, работать как  с массивом объектов.
// SplDoublyLinkedList позволяет работать с двусвязанными списками. На основе SplDoublyLinkedList реализуются SplStack
// и SplQueue. SplStack реализует стек - первыми из списка извлекаются по порядку те элементы, которые были добавлены
// последними. SplQueue реализует очередь - первыми наоборот извлекаются те элементы, которые были добавлены первыми.

// 6. Найдите все ошибки в коде:

interface MyInt {
    public function funcI();
    private function funcP(); // методы в интерфейсе нельзя делать приватными.
}
class A {
protected prop1; // свойствам нужно задавать значение по умолчанию или null.
private prop2;

    function funcA(){ // функцию-геттер надо называть понятно getProp2
        return $this->prop2;
    }
}
class B extends A {
    function funcB(){
        return $this->prop1;
    }
}
class C extends B implements MyInt { // класс реализует интерфейс MyInt, но не реализует его метод funcI()
    function funcB(){ // здесь переопределили родительский метод, но ничего не поменялось.
        return $this->prop1;
    }
    private function funcP(){ // т.к. сделали этот метод приватным, теперь не можем его реализовать.
        return 123;
    }
}
$b = new B();
$b->funcA(); // т.к. свойству prop2 ничего не присвоили, метод ничего не возвращает. Также возвращаемое значение никуда
             // не присваивается.
$c = new C(); // если класс не имеет реализации метода funcI()интерфейса MyInt, то он должен быть объявлен астрактным,
              // а значит создать от него объект нельзя.
$c->funcI(); // метод не имеет реализации.
